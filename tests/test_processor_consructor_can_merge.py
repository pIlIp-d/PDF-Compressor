from glob import glob
import os
import shutil
from unittest import TestCase

from tests.help_classes import clean_up_after_class, SimpleMergeProcessor, SimpleFakeMergeProcessor, TESTDATA_DIR


class TestProcessorConstructorCanMerge(TestCase):

    @staticmethod
    def __get_path_variations() -> list[list[str]]:
        for variation in [
            [os.path.join(TESTDATA_DIR, "empty.txt"), os.path.join(TESTDATA_DIR, "output", "output.txt"), False],
            [os.path.join(TESTDATA_DIR, "testFolder"), os.path.join(TESTDATA_DIR, "output", "output.txt"), True],
            [os.path.join(TESTDATA_DIR, "empty.txt"), os.path.join(TESTDATA_DIR, "output", "outputFolder"), False],
            [os.path.join(TESTDATA_DIR, "testFolder"), os.path.join(TESTDATA_DIR, "output","outputFolder"), False],
            [os.path.join(TESTDATA_DIR, "empty.txt"), "merge", True],
            [os.path.join(TESTDATA_DIR, "testFolder"), "merge", True],
            [os.path.join(TESTDATA_DIR, "empty.txt"), "default", False],
            [os.path.join(TESTDATA_DIR, "testFolder"), "default", False],
        ]:
            yield variation

    @classmethod
    def __remove_files_if_can_merge_test_was_successful(cls):
        shutil.rmtree(os.path.join(TESTDATA_DIR, "output"), ignore_errors=True)
        for f in glob(os.path.join(TESTDATA_DIR, "*_merged_*")) + glob(os.path.join(TESTDATA_DIR, "*_processed*")):
            if os.path.isfile(f):
                os.remove(f)
            else:
                shutil.rmtree(f, ignore_errors=True)

    def __get_default_result_path(self, source_path):
        if os.path.isfile(source_path):
            merged_files = glob(os.path.join(TESTDATA_DIR, "*_merged_*"))
            if len(merged_files) > 0:
                return merged_files[0]
            else:
                # destination path was default
                return source_path[:-len(".txt")] + "_processed.txt"
        elif os.path.isdir(source_path):
            return source_path + "_processed"
        self.fail("no result files created")

    def test_processor_can_merge_is_true_with_merge_processor(self):
        processor = SimpleMergeProcessor(True)
        for source_path, destination_path, should_merge in self.__get_path_variations():
            self.__remove_files_if_can_merge_test_was_successful()
            processor.process(source_path, destination_path)
            if should_merge:
                merged_file = destination_path
                if destination_path == "merge":
                    # rebuild autogenerated destination path (->merged_file)
                    merged_file = self.__get_default_result_path(source_path)
                    if os.path.isdir(merged_file):
                        merged_file = glob(os.path.join(merged_file, "*"))[0]
                # compare the values of all input and the merged output file
                elif os.path.isdir(destination_path):
                    merged_file = glob(os.path.join(destination_path, "*"))[0]

                with open(merged_file) as file:
                    merged_string = ""
                    for f_path in sorted(glob(os.path.join(source_path, "*txt"))):
                        with open(f_path) as f:
                            merged_string += f.read()
                    self.assertEqual(merged_string, file.read())

            self.__remove_files_if_can_merge_test_was_successful()


    def test_processor_can_merge_is_true_but_processor_doesnt_support_merge(self):
        processor = SimpleFakeMergeProcessor(True)
        for source_path, destination_path, should_merge in self.__get_path_variations():
            if should_merge or source_path.endswith("notfound.txt"):
                self.assertRaises(ValueError, processor.process, source_path, destination_path)
            else:
                processor.process(source_path, destination_path)
                self.__remove_files_if_can_merge_test_was_successful()

    def test_processor_can_merge_is_false_with_merge_processor(self):
        processor = SimpleMergeProcessor(False)
        for source_path, destination_path, should_merge in self.__get_path_variations():
            if should_merge or source_path.endswith("notfound.txt"):
                self.assertRaises(ValueError, processor.process, source_path, destination_path)
            else:
                processor.process(source_path, destination_path)
                self.__remove_files_if_can_merge_test_was_successful()

    def test_processor_can_merge_is_false_but_processor_doesnt_support_merge(self):
        processor = SimpleFakeMergeProcessor(False)
        for source_path, destination_path, should_merge in self.__get_path_variations():
            if should_merge or source_path.endswith("notfound.txt"):
                self.assertRaises(ValueError, processor.process, source_path, destination_path)
            else:
                processor.process(source_path, destination_path)
                self.__remove_files_if_can_merge_test_was_successful()

    @classmethod
    def setUpClass(cls) -> None:
        cls.__remove_files_if_can_merge_test_was_successful()

    @classmethod
    def tearDownClass(cls) -> None:
        clean_up_after_class()
        cls.__remove_files_if_can_merge_test_was_successful()
